================================================================================
RULE GENERATION OPTIMIZATION - QUICK REFERENCE
================================================================================

CURRENT SITUATION
================================================================================
Total Rules Generated: 19
  - Pattern-based: 6 rules
  - LLM-based: 13 rules
Execution Time: 16-21 seconds
Problem: Too many redundant rules


OPTIMIZATION STRATEGIES (4 Approaches)
================================================================================

STRATEGY 1: LIMIT LLM RULES IN PROMPT
────────────────────────────────────────────────────────────────────────────
File: kg_builder/services/multi_schema_llm_service.py
Lines: 437-490

Current Prompt:
  "For each rule, provide: rule_name, source_schema, ..."
  (No limit on number of rules)

Optimized Prompt:
  "Generate ONLY the TOP 3 MOST IMPORTANT reconciliation rules.
   
   CRITICAL CONSTRAINTS:
   1. Generate MAXIMUM 3 rules total (not per relationship)
   2. Prioritize by confidence score (highest first)
   3. Avoid duplicate match strategies
   4. Each rule must have UNIQUE source_columns + target_columns
   5. Skip rules with confidence < 0.8"

Expected Result: 13 LLM rules → 3 LLM rules


STRATEGY 2: SMART DEDUPLICATION
────────────────────────────────────────────────────────────────────────────
File: kg_builder/services/reconciliation_service.py
Lines: 83

Current Code:
  unique_rules = self._deduplicate_rules(filtered_rules)

Enhanced Code:
  def _deduplicate_rules(self, rules):
      """Remove semantically equivalent rules."""
      unique_rules = []
      seen_combinations = set()
      
      # Sort by confidence (highest first)
      sorted_rules = sorted(rules, key=lambda r: r.confidence_score, reverse=True)
      
      for rule in sorted_rules:
          # Create signature: (source_cols, target_cols, match_type)
          signature = (
              tuple(sorted(rule.source_columns)),
              tuple(sorted(rule.target_columns)),
              rule.match_type
          )
          
          # Skip if we've already seen this combination
          if signature not in seen_combinations:
              unique_rules.append(rule)
              seen_combinations.add(signature)
      
      return unique_rules

Expected Result: Remove 30-40% of duplicate rules


STRATEGY 3: CONFIDENCE-BASED FILTERING
────────────────────────────────────────────────────────────────────────────
File: kg_builder/services/reconciliation_service.py
Lines: 80

Current Code:
  filtered_rules = [r for r in all_rules if r.confidence_score >= min_confidence]

Enhanced Code:
  def _filter_rules_intelligently(self, rules, min_confidence=0.7):
      """Filter rules by confidence and importance."""
      
      # Group by (source_table, target_table)
      rule_groups = {}
      for rule in rules:
          key = (rule.source_table, rule.target_table)
          if key not in rule_groups:
              rule_groups[key] = []
          rule_groups[key].append(rule)
      
      filtered = []
      for key, group in rule_groups.items():
          # Sort by confidence
          sorted_group = sorted(group, key=lambda r: r.confidence_score, reverse=True)
          
          # Keep only top 2 rules per table pair
          for rule in sorted_group[:2]:
              if rule.confidence_score >= min_confidence:
                  filtered.append(rule)
      
      return filtered

Expected Result: Keep only best rules per table pair


STRATEGY 4: RELATIONSHIP FILTERING
────────────────────────────────────────────────────────────────────────────
File: kg_builder/services/reconciliation_service.py
Lines: 150-179

Current Code:
  query = """
  MATCH (source)-[r]->(target)
  RETURN source.label, target.label, type(r), properties(r)
  """

Optimized Code:
  query = """
  MATCH (source)-[r]->(target)
  WHERE r.confidence >= 0.8
  RETURN source.label, target.label, type(r), properties(r)
  """

Expected Result: Fewer relationships → Fewer rules


================================================================================
IMPLEMENTATION ROADMAP
================================================================================

PHASE 1: QUICK WINS (5 minutes)
────────────────────────────────────────────────────────────────────────────
1. Update LLM prompt to limit to 3 rules
   File: multi_schema_llm_service.py, lines 437-490
   
2. Enhance deduplication logic
   File: reconciliation_service.py, line 83
   
3. Add per-table-pair rule limit
   File: reconciliation_service.py, line 80

Expected Result: 19 rules → 8-10 rules (50% reduction)


PHASE 2: ADVANCED FILTERING (10 minutes)
────────────────────────────────────────────────────────────────────────────
1. Filter relationships by confidence
   File: reconciliation_service.py, lines 150-179
   
2. Add rule importance scoring
   File: reconciliation_service.py (new method)
   
3. Implement rule consolidation
   File: reconciliation_service.py (new method)

Expected Result: 8-10 rules → 5-7 rules (75% reduction)


PHASE 3: TESTING & VALIDATION (5 minutes)
────────────────────────────────────────────────────────────────────────────
1. Run test with optimizations
   Command: python test_e2e_reconciliation_simple.py
   
2. Verify rule quality
   Check: Confidence scores, match accuracy
   
3. Compare execution time
   Before: 16-21 seconds
   After: 4-6 seconds (target)


================================================================================
EXPECTED RESULTS
================================================================================

BEFORE OPTIMIZATION
────────────────────────────────────────────────────────────────────────────
Total Rules: 19
  - Pattern-based: 6
  - LLM-based: 13
Execution Time: 16-21 seconds
Rule Quality: Mixed (some redundant)
Maintainability: Hard (too many rules)


AFTER PHASE 1 (Quick Wins)
────────────────────────────────────────────────────────────────────────────
Total Rules: 8-10
  - Pattern-based: 5-6
  - LLM-based: 3-4
Execution Time: 8-12 seconds (50% faster)
Rule Quality: Good
Maintainability: Better


AFTER PHASE 1 + 2 (Full Optimization)
────────────────────────────────────────────────────────────────────────────
Total Rules: 5-7
  - Pattern-based: 3-4
  - LLM-based: 2-3
Execution Time: 4-6 seconds (75% faster)
Rule Quality: Excellent
Maintainability: Easy


================================================================================
KEY PRINCIPLES
================================================================================

✅ Quality over Quantity
   5 high-confidence rules > 19 mixed-confidence rules

✅ Avoid Redundancy
   One rule per unique column combination

✅ Prioritize Relationships
   Focus on strongest relationships first

✅ Limit LLM Output
   Explicit constraints in prompt

✅ Smart Deduplication
   Remove semantic duplicates


================================================================================
COMPARISON TABLE
================================================================================

Aspect                  Current         Optimized
────────────────────────────────────────────────────────────────────────────
Total Rules             19              5-7
LLM Rules               13              2-3
Pattern Rules           6               3-4
Execution Time          16-21s          4-6s
Redundancy              High            Low
Rule Quality            Mixed           High
Maintainability         Hard            Easy
Performance             Slow            Fast


================================================================================
FILES TO MODIFY
================================================================================

1. kg_builder/services/multi_schema_llm_service.py
   - Update _build_reconciliation_rules_prompt() method
   - Add max_rules_per_relationship parameter
   - Add max_total_rules parameter

2. kg_builder/services/reconciliation_service.py
   - Enhance _deduplicate_rules() method
   - Add _filter_rules_intelligently() method
   - Update _get_kg_relationships() query

3. test_e2e_reconciliation_simple.py
   - Run test to verify optimization
   - Compare rule count and execution time


================================================================================
NEXT STEPS
================================================================================

1. Review this document
2. Implement Phase 1 (Quick Wins)
3. Test with current data
4. Measure impact (rule count, execution time)
5. Implement Phase 2 (Advanced)
6. Document results


================================================================================
Version: 1.0
Date: 2025-10-24
Status: Ready for Implementation
================================================================================

